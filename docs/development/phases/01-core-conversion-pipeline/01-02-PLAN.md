---
phase: 01-core-conversion-pipeline
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - stages/01-validate.sh
  - stages/02-concat.sh
  - stages/03-convert.sh
autonomous: true

must_haves:
  truths:
    - "A folder of sorted MP3 files produces a single M4B with one chapter per source MP3"
    - "A single-MP3 input produces a valid M4B without chapter markers"
    - "Output is 64kbps mono AAC-LC with -movflags +faststart"
    - "Sources at or below 64kbps are transcoded at source rate, not upscaled"
    - "Chapter count in output M4B matches number of input MP3 files"
  artifacts:
    - path: "stages/01-validate.sh"
      provides: "Input validation -- MP3 existence, readability, ffprobe checks, duration/bitrate detection"
      contains: "validate_audio_file"
    - path: "stages/02-concat.sh"
      provides: "File list generation and FFMETADATA1 chapter file creation"
      contains: "FFMETADATA1"
    - path: "stages/03-convert.sh"
      provides: "Single-pass ffmpeg concat + AAC encode + chapter inject + faststart"
      contains: "movflags +faststart"
  key_links:
    - from: "stages/01-validate.sh"
      to: "lib/ffmpeg.sh"
      via: "source and call get_duration, get_bitrate, validate_audio_file"
      pattern: "source.*lib/ffmpeg\\.sh"
    - from: "stages/02-concat.sh"
      to: "stages/03-convert.sh"
      via: "files.txt and metadata.txt consumed by ffmpeg"
      pattern: "files\\.txt|metadata\\.txt"
    - from: "stages/03-convert.sh"
      to: "lib/manifest.sh"
      via: "manifest_set to record output file, chapter count, bitrate"
      pattern: "manifest_set"
---

<objective>
Implement the three core stage scripts that perform MP3 validation, chapter metadata generation, and M4B conversion.

Purpose: These stages are the conversion engine -- everything else (CLI, manifest tracking) wraps around them. After this plan, a caller can source the libs, set up a work directory, and run stages 01 through 03 to produce a chaptered M4B from MP3 input.

Output: `stages/01-validate.sh`, `stages/02-concat.sh`, `stages/03-convert.sh`
</objective>

<execution_context>
@/Users/rico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-conversion-pipeline/01-RESEARCH.md
# 01-01 creates lib/core.sh, lib/ffmpeg.sh, lib/manifest.sh, lib/sanitize.sh, config.env
# Source those files -- do NOT recreate them
</context>

<tasks>

<task type="auto">
  <name>Task 1: Input validation stage</name>
  <files>stages/01-validate.sh</files>
  <action>
Create `stages/01-validate.sh` -- validates that the input directory contains processable MP3 files.

Script structure:
- Shebang: `#!/usr/bin/env bash` with `set -euo pipefail`
- Source `lib/core.sh`, `lib/ffmpeg.sh`, `lib/manifest.sh` relative to script location using `SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"`
- Expect `WORK_DIR`, `SOURCE_PATH`, and `BOOK_HASH` as environment variables (set by caller/CLI)

Main function `stage_validate()`:
1. Check `SOURCE_PATH` exists and is a directory
2. Find all MP3 files: `find "$SOURCE_PATH" -type f -iname "*.mp3" | sort -V` (natural sort per research pitfall #4)
3. If zero MP3s found, `die "No MP3 files found in $SOURCE_PATH"`
4. Count files and store in `FILE_COUNT`
5. For each MP3, call `validate_audio_file` from lib/ffmpeg.sh -- die on first invalid file
6. Detect source bitrate: probe the first MP3 with `get_bitrate`, convert from bits/sec to kbps (`bitrate_kbps=$((bitrate_bps / 1000))`)
7. Calculate total duration: sum `get_duration` across all MP3s using `bc` (accumulate float seconds)
8. Determine target bitrate: if `$bitrate_kbps -le 64` then `TARGET_BITRATE="${bitrate_kbps}k"` and log a warning about low-bitrate source, else `TARGET_BITRATE="64k"` (FR-CONV-03)
9. Store file list to `$WORK_DIR/mp3_files.txt` (one absolute path per line, sorted)
10. Update manifest via `manifest_set`:
    - `stages.validate.status=completed`
    - `stages.validate.file_count=$FILE_COUNT`
    - `stages.validate.total_duration_sec=$TOTAL_DURATION`
    - `stages.validate.source_bitrate_kbps=$bitrate_kbps`
    - `stages.validate.target_bitrate=$TARGET_BITRATE`

Export `TARGET_BITRATE` and `FILE_COUNT` for downstream stages.

If called directly (not sourced), run `stage_validate` at end:
```bash
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  stage_validate
fi
```
  </action>
  <verify>
`bash -n stages/01-validate.sh` exits 0 (syntax check). The script sources lib files without error when they exist. Grep confirms: `sort -V`, `validate_audio_file`, `get_bitrate`, `get_duration`, `manifest_set`, `TARGET_BITRATE`, shebang is `#!/usr/bin/env bash`.
  </verify>
  <done>
Stage 01 validates MP3 input, detects bitrate, calculates total duration, writes sorted file list to work dir, and records results in manifest. Low-bitrate sources get a warning and use source rate instead of 64k.
  </done>
</task>

<task type="auto">
  <name>Task 2: Concat preparation and M4B conversion stages</name>
  <files>stages/02-concat.sh, stages/03-convert.sh</files>
  <action>
**stages/02-concat.sh** -- generates the ffmpeg concat file list and FFMETADATA1 chapter file.

Script structure: same boilerplate as 01-validate.sh (shebang, set flags, source libs, expect env vars).

Main function `stage_concat()`:
1. Read `$WORK_DIR/mp3_files.txt` (produced by stage 01)
2. Generate `$WORK_DIR/files.txt` in ffmpeg concat demuxer format:
   - For each line in mp3_files.txt, escape apostrophes with triple-apostrophe (`sed "s/'/'''/g"`) then wrap: `file '/escaped/path'`
   - Per research pitfall #3
3. Determine book title from `SOURCE_PATH` basename (use `sanitize_chapter_title` from lib/sanitize.sh)
4. Generate `$WORK_DIR/metadata.txt` -- FFMETADATA1 format:
   ```
   ;FFMETADATA1
   title=$BOOK_TITLE
   artist=Unknown
   album=$BOOK_TITLE
   ```
5. If FILE_COUNT equals 1, skip chapter generation (single-file books get no chapters per success criteria #2). Write manifest and return.
6. For multi-file: iterate `mp3_files.txt`, for each file:
   - Get duration via `get_duration` (float seconds)
   - Convert to integer milliseconds: `echo "$duration_s * 1000" | bc | cut -d. -f1` (research pitfall #5)
   - Derive chapter title: basename without extension, passed through `sanitize_chapter_title`
   - Append to metadata.txt:
     ```
     [CHAPTER]
     TIMEBASE=1/1000
     START=$chapter_start
     END=$((chapter_start + duration_ms))
     title=$chapter_title
     ```
   - Increment `chapter_start` by `duration_ms`
   - Increment counter
7. Update manifest: `stages.concat.status=completed`, `stages.concat.chapter_count=$counter`

**stages/03-convert.sh** -- runs ffmpeg to produce the final M4B.

Main function `stage_convert()`:
1. Read TARGET_BITRATE from manifest (or env var fallback): `TARGET_BITRATE=$(manifest_get "stages.validate.target_bitrate")`
2. Read FILE_COUNT from manifest
3. Set output path: `$WORK_DIR/output/$(basename "$SOURCE_PATH").m4b` -- create `$WORK_DIR/output/` dir
4. Build ffmpeg command:
   ```bash
   ffmpeg -y \
     -f concat -safe 0 -i "$WORK_DIR/files.txt" \
     -i "$WORK_DIR/metadata.txt" \
     -map_metadata 1 \
     -map 0:a \
     -c:a aac -b:a "$TARGET_BITRATE" -ac 1 \
     -movflags +faststart \
     "$output_file"
   ```
   Key flags:
   - `-map_metadata 1` injects FFMETADATA1 (research pitfall #1 -- concat demuxer drops chapters)
   - `-ac 1` for mono (FR-CONV-03)
   - `-movflags +faststart` (research pitfall #2)
5. Execute via `run` wrapper from lib/core.sh (respects DRY_RUN)
6. Post-conversion validation (skip if DRY_RUN):
   - Verify output file exists and size > 0
   - Verify codec: `ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of csv=p=0 "$output_file"` should be "aac"
   - If FILE_COUNT > 1, verify chapter count: `ffprobe -v error -show_chapters "$output_file" | grep -c "^\[CHAPTER\]"` matches FILE_COUNT
   - If chapter count mismatch, `log_warn` but don't die (non-fatal)
   - Verify faststart: `ffprobe -v error -show_format "$output_file"` should contain format_name including "mov" or "mp4"
7. Update manifest:
   - `stages.convert.status=completed`
   - `stages.convert.output_file=$output_file`
   - `stages.convert.bitrate=$TARGET_BITRATE`
   - `stages.convert.codec=aac`
   - `stages.convert.chapter_count=$actual_chapter_count`

Both scripts use the same "run if not sourced" guard pattern.
  </action>
  <verify>
`bash -n stages/02-concat.sh && bash -n stages/03-convert.sh` exits 0. Grep confirms:
- 02-concat.sh: `FFMETADATA1`, `TIMEBASE=1/1000`, apostrophe escaping (`'''`), `sanitize_chapter_title`, single-file skip logic
- 03-convert.sh: `-map_metadata 1`, `-movflags +faststart`, `-ac 1`, `-b:a "$TARGET_BITRATE"`, `ffprobe.*show_chapters`, chapter count validation
  </verify>
  <done>
Stage 02 generates concat file list with apostrophe escaping and FFMETADATA1 chapters from MP3 durations (skipping chapters for single-file input). Stage 03 runs single-pass ffmpeg concat+encode+chapter-inject+faststart and validates output codec, chapter count, and file integrity.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the full stage chain:

1. **Syntax:** `bash -n stages/01-validate.sh && bash -n stages/02-concat.sh && bash -n stages/03-convert.sh`
2. **Lib dependencies:** Each stage sources lib/core.sh, lib/ffmpeg.sh, lib/manifest.sh (and 02 also sources lib/sanitize.sh)
3. **Data flow:** Stage 01 writes `mp3_files.txt` -> Stage 02 reads it, writes `files.txt` + `metadata.txt` -> Stage 03 reads both, writes M4B
4. **FR-CONV-01:** Single MP3 -> valid M4B (no chapters)
5. **FR-CONV-02:** Multiple MP3s -> single M4B with chapter per file
6. **FR-CONV-03:** 64kbps mono default, low-bitrate sources use source rate
7. **FR-CHAP-01:** Chapters via FFMETADATA1 with cumulative timestamps from file durations
8. **No lib files created:** Only `stages/*.sh` files exist -- libs are sourced from 01-01
</verification>

<success_criteria>
- Three stage scripts exist: `stages/01-validate.sh`, `stages/02-concat.sh`, `stages/03-convert.sh`
- All three pass `bash -n` syntax validation
- Stage 01 finds MP3s with natural sort, validates them, detects bitrate, calculates duration
- Stage 02 generates apostrophe-safe concat list and FFMETADATA1 chapters (skipped for single files)
- Stage 03 runs single-pass ffmpeg with `-map_metadata 1 -ac 1 -movflags +faststart` and validates output
- No lib/ files created (those belong to plan 01-01)
- Manifest updated at each stage completion
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-conversion-pipeline/01-02-SUMMARY.md`
</output>
