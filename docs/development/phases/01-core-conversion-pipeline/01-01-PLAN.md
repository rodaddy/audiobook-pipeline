---
phase: 01-core-conversion-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/audiobook-convert
  - lib/core.sh
  - lib/ffmpeg.sh
  - lib/manifest.sh
  - lib/sanitize.sh
  - config.env.example
  - VERSION
autonomous: true

must_haves:
  truths:
    - "Sourcing lib/core.sh provides log_info, log_error, log_warn, log_debug, die, and run functions"
    - "Sourcing lib/ffmpeg.sh provides get_duration, get_bitrate, get_codec, get_channels, and validate_audio_file functions"
    - "Sourcing lib/manifest.sh provides manifest_create, manifest_read, manifest_update, check_book_status, and get_next_stage functions"
    - "Sourcing lib/sanitize.sh provides sanitize_filename, sanitize_chapter_title, and generate_book_hash functions"
    - "config.env.example documents all configurable paths and defaults"
    - "bin/audiobook-convert sources all libraries and config without error"
  artifacts:
    - path: "lib/core.sh"
      provides: "Structured logging, die(), run() with dry-run support"
      contains: "log_info"
    - path: "lib/ffmpeg.sh"
      provides: "FFprobe wrapper functions for duration, bitrate, codec, channels, validation"
      contains: "get_duration"
    - path: "lib/manifest.sh"
      provides: "JSON manifest CRUD via jq with atomic writes"
      contains: "manifest_create"
    - path: "lib/sanitize.sh"
      provides: "Filename sanitization, chapter title cleaning, book hash generation"
      contains: "generate_book_hash"
    - path: "config.env.example"
      provides: "All configuration variables with defaults"
      contains: "WORK_DIR"
    - path: "bin/audiobook-convert"
      provides: "CLI entry point skeleton that sources libs and config"
      contains: "source.*lib/core.sh"
    - path: "VERSION"
      provides: "Version string"
      contains: "0.1.0"
  key_links:
    - from: "bin/audiobook-convert"
      to: "lib/core.sh"
      via: "source"
      pattern: "source.*LIB_DIR/core.sh"
    - from: "lib/manifest.sh"
      to: "jq"
      via: "JSON manipulation"
      pattern: "jq"
    - from: "lib/ffmpeg.sh"
      to: "ffprobe"
      via: "subprocess"
      pattern: "ffprobe"
---

<objective>
Create the project skeleton for audiobook-pipeline: directory layout, configuration, and four shared libraries (core logging, ffprobe helpers, manifest state tracking, filename sanitization). This plan produces the foundation that plans 01-02 (conversion) and 01-03 (CLI) build on.

Purpose: Every subsequent plan imports these libraries. Getting logging, manifest tracking, and ffprobe wrappers right here means the conversion and CLI plans can focus on their actual logic.

Output: Runnable `bin/audiobook-convert` skeleton that sources all libs, plus config template and VERSION file.
</objective>

<execution_context>
@/Users/rico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-conversion-pipeline/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project skeleton, config, and core library</name>
  <files>
    bin/audiobook-convert
    lib/core.sh
    config.env.example
    VERSION
  </files>
  <action>
Create the project directory structure and three foundational files.

**VERSION** -- contains `0.1.0` (single line, no trailing newline).

**config.env.example** -- all configurable variables with sensible defaults:
```
# Audiobook Pipeline Configuration
# Copy to config.env and adjust as needed

# Directories
WORK_DIR="/var/lib/audiobook-pipeline/work"
MANIFEST_DIR="/var/lib/audiobook-pipeline/manifests"
LOG_DIR="/var/log/audiobook-pipeline"

# Encoding defaults
BITRATE="64k"
CHANNELS="1"
CODEC="aac"

# Permissions (readarr user)
FILE_OWNER="2018:2000"
FILE_MODE="644"
DIR_MODE="755"

# Behavior
DRY_RUN=false
FORCE=false
VERBOSE=false
CLEANUP_WORK_DIR=true
LOG_LEVEL="INFO"
```

**lib/core.sh** -- structured key=value logging library. Follow the exact patterns from 01-RESEARCH.md:
- Log levels: DEBUG=0, INFO=1, WARN=2, ERROR=3
- `CURRENT_LOG_LEVEL` set from `$LOG_LEVEL` config variable (default INFO)
- `log()` function: outputs `timestamp=ISO8601 level=LEVEL stage=$STAGE book_hash=$BOOK_HASH message="escaped msg"` format
- Writes to both stderr (for terminal visibility) and appends to `$LOG_DIR/convert.log`
- Create log directory if missing: `mkdir -p "$LOG_DIR"`
- Convenience functions: `log_debug`, `log_info`, `log_warn`, `log_error`
- `die()` -- logs ERROR then `exit 1`
- `run()` -- if `$DRY_RUN` is true, logs what would execute and returns 0. Otherwise runs the command via `eval`, logs failures, returns exit code. NOTE: use `"$@"` for command passing, not string eval (avoids quoting bugs).
- `require_cmd()` -- checks a command exists via `command -v`, dies with helpful message if missing
- All functions use `#!/usr/bin/env bash` shebang and `set -euo pipefail` guard at top

**bin/audiobook-convert** -- CLI entry point skeleton:
- Shebang: `#!/usr/bin/env bash`
- `set -euo pipefail`
- Resolve `SCRIPT_DIR` via `$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)`
- `LIB_DIR="$SCRIPT_DIR/../lib"`
- Default `CONFIG_FILE` to `$SCRIPT_DIR/../config.env`, allow override via `--config` flag
- Source config.env (if exists), then source all four libs in order: core.sh, ffmpeg.sh, manifest.sh, sanitize.sh
- Argument parsing loop per research patterns: `--dry-run`, `--force`, `-v|--verbose`, `-c|--config FILE`, `-h|--help`, positional `SOURCE_PATH`
- `show_help()` function with usage text
- Export `DRY_RUN`, `FORCE`, `VERBOSE`
- Set `CURRENT_LOG_LEVEL` to `$LOG_LEVEL_DEBUG` if `$VERBOSE` is true
- Validate `SOURCE_PATH` is provided and is a directory, die otherwise
- Stub `main()` function that logs "Pipeline starting for $SOURCE_PATH" and exits 0 (plans 01-02 and 01-03 fill this in)
- `chmod +x bin/audiobook-convert`
  </action>
  <verify>
Run from project root:
```bash
chmod +x bin/audiobook-convert
bash -n lib/core.sh          # syntax check
bash -n bin/audiobook-convert # syntax check
./bin/audiobook-convert --help | grep -q "dry-run"
./bin/audiobook-convert --dry-run /tmp 2>&1 | grep -q "Pipeline starting"
```
All four commands exit 0.
  </verify>
  <done>
bin/audiobook-convert parses --dry-run, --force, --verbose, --config, --help and sources lib/core.sh. Logging functions output structured key=value format. run() respects DRY_RUN. die() exits non-zero.
  </done>
</task>

<task type="auto">
  <name>Task 2: FFprobe helpers, manifest library, and sanitization</name>
  <files>
    lib/ffmpeg.sh
    lib/manifest.sh
    lib/sanitize.sh
  </files>
  <action>
Create three library files. All use `#!/usr/bin/env bash` shebang. None should call `set -euo pipefail` (they are sourced into the main script which already sets it).

**lib/ffmpeg.sh** -- FFprobe wrapper functions, following 01-RESEARCH.md patterns exactly:

- `get_duration FILE` -- returns float seconds via `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1`
- `get_bitrate FILE` -- returns bits/sec integer via `ffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1:nokey=1`
- `get_codec FILE` -- returns codec name via `ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1`
- `get_channels FILE` -- returns channel count (1 or 2) via `ffprobe -v error -select_streams a:0 -show_entries stream=channels -of default=noprint_wrappers=1:nokey=1`
- `get_sample_rate FILE` -- returns sample rate in Hz via `ffprobe -v error -select_streams a:0 -show_entries stream=sample_rate -of default=noprint_wrappers=1:nokey=1`
- `validate_audio_file FILE` -- checks file exists, ffprobe can read it, has an audio stream. Returns 0 on success, 1 on failure. Logs errors via `log_error`.
- `duration_to_timestamp SECONDS` -- converts float seconds to HH:MM:SS via bc (per research patterns)
- `count_chapters FILE` -- returns chapter count via `ffprobe -v error -show_chapters FILE | grep -c "^\[CHAPTER\]"`, returns 0 if no chapters

**lib/manifest.sh** -- JSON manifest state management via jq:

- `manifest_path BOOK_HASH` -- returns `$MANIFEST_DIR/$BOOK_HASH.json`
- `manifest_create BOOK_HASH SOURCE_PATH` -- creates new manifest JSON with schema from research: `book_hash`, `source_path`, `created_at` (ISO8601 via `date -u +%Y-%m-%dT%H:%M:%SZ`), `status: "pending"`, empty `stages` object (validate/concat/convert/cleanup all pending), empty `metadata` object. Writes atomically (temp file + mv).
- `manifest_read BOOK_HASH FIELD` -- reads a field via `jq -r ".${FIELD}"` from manifest file. Returns empty string if file missing.
- `manifest_update BOOK_HASH JQ_FILTER` -- applies jq filter to manifest. Uses atomic write pattern: `jq "$JQ_FILTER" "$manifest" > "$manifest.tmp.$$" && mv "$manifest.tmp.$$" "$manifest"`. Log the update.
- `manifest_set_stage BOOK_HASH STAGE STATUS` -- convenience wrapper: sets `.stages.$STAGE.status` and if status is "completed", also sets `.stages.$STAGE.completed_at`.
- `check_book_status BOOK_HASH` -- returns "new" if no manifest, otherwise returns `.status`. Exit code 1 if status is "completed" (signals skip), 0 otherwise.
- `get_next_stage BOOK_HASH` -- iterates stages (validate, concat, convert, cleanup), returns first non-completed stage name. Returns "done" if all completed.
- `mkdir -p "$MANIFEST_DIR"` at top of file (safe to re-run)

**lib/sanitize.sh** -- filename and path sanitization, following 01-RESEARCH.md patterns:

- `sanitize_filename FILENAME` -- replaces unsafe chars `/ \ : " * ? < > | ;` with underscore, removes leading dots, collapses repeated underscores, truncates to 255 bytes preserving extension.
- `sanitize_chapter_title TITLE` -- more permissive: replaces same unsafe chars with spaces instead of underscores, collapses multiple spaces, trims leading/trailing whitespace.
- `generate_book_hash SOURCE_PATH` -- generates a 16-char hex hash from source path + sorted MP3 file list via `shasum -a 256 | cut -d' ' -f1 | cut -c1-16`. This is the idempotency key.

Cross-platform note for `stat`: use `stat -f%z "$file" 2>/dev/null || stat -c%s "$file"` when file size is needed (macOS vs Linux compatibility per research pitfall #8).
  </action>
  <verify>
Run from project root:
```bash
bash -n lib/ffmpeg.sh     # syntax check
bash -n lib/manifest.sh   # syntax check
bash -n lib/sanitize.sh   # syntax check

# Integration test: source chain works
bash -c '
  export LOG_LEVEL="INFO" DRY_RUN=false FORCE=false VERBOSE=false
  export WORK_DIR="/tmp/ab-test" MANIFEST_DIR="/tmp/ab-test/manifests" LOG_DIR="/tmp/ab-test/logs"
  source lib/core.sh
  source lib/ffmpeg.sh
  source lib/manifest.sh
  source lib/sanitize.sh
  log_info "Integration test"
  echo "sanitize: $(sanitize_filename "Who'\''s Afraid: Of Virginia?")"
  echo "hash: $(generate_book_hash /tmp)"
  echo "All libraries loaded OK"
'
```

Expected: no syntax errors, "Integration test" in structured log format, sanitized filename printed, hash printed, "All libraries loaded OK" at end.
  </verify>
  <done>
All four lib files source without error. FFprobe wrappers return correct values for valid audio files. Manifest functions create/read/update JSON atomically via jq. Sanitization handles apostrophes, colons, and special characters. generate_book_hash produces consistent 16-char hex for the same input.
  </done>
</task>

</tasks>

<verification>
Full integration check from project root:

```bash
# 1. All files exist
test -f bin/audiobook-convert && test -f lib/core.sh && test -f lib/ffmpeg.sh && \
test -f lib/manifest.sh && test -f lib/sanitize.sh && test -f config.env.example && \
test -f VERSION && echo "All files present"

# 2. Shebangs correct (LAW 7)
head -1 bin/audiobook-convert lib/core.sh lib/ffmpeg.sh lib/manifest.sh lib/sanitize.sh | \
  grep -c "#!/usr/bin/env bash" | grep -q "5"

# 3. CLI works
chmod +x bin/audiobook-convert
./bin/audiobook-convert --help
./bin/audiobook-convert --dry-run /tmp 2>&1 | grep -q "Pipeline starting"

# 4. Library chain loads cleanly
bash -c '
  export LOG_LEVEL=INFO DRY_RUN=false FORCE=false VERBOSE=false
  export WORK_DIR=/tmp/ab-test MANIFEST_DIR=/tmp/ab-test/manifests LOG_DIR=/tmp/ab-test/logs
  source lib/core.sh && source lib/ffmpeg.sh && source lib/manifest.sh && source lib/sanitize.sh
  type log_info && type get_duration && type manifest_create && type sanitize_filename
  echo "ALL FUNCTIONS AVAILABLE"
'
```
</verification>

<success_criteria>
1. `bin/audiobook-convert --help` prints usage with --dry-run, --force, --verbose, --config flags
2. `bin/audiobook-convert --dry-run /tmp` logs structured output and exits 0
3. All four lib/ files pass `bash -n` syntax check
4. Sourcing all four libs in sequence exposes: log_info, log_error, die, run, get_duration, get_bitrate, validate_audio_file, manifest_create, manifest_update, check_book_status, get_next_stage, sanitize_filename, generate_book_hash
5. VERSION contains "0.1.0"
6. config.env.example documents WORK_DIR, MANIFEST_DIR, LOG_DIR, BITRATE, CHANNELS, FILE_OWNER, DRY_RUN, FORCE
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-conversion-pipeline/01-01-SUMMARY.md`
</output>
