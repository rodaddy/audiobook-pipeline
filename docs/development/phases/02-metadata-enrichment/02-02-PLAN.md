---
phase: 02-metadata-enrichment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/audnexus.sh
  - config.env.example
autonomous: true

must_haves:
  truths:
    - "fetch_audnexus_book returns valid JSON metadata for a known ASIN"
    - "fetch_audnexus_chapters returns chapter array with ms-precision timestamps"
    - "Successful API responses are cached as JSON files with 30-day TTL"
    - "Cached responses are served without HTTP requests on subsequent calls"
    - "API failures (404, 429, network) return non-zero exit without crashing"
    - "download_cover_art fetches high-res JPEG and validates magic bytes"
    - "validate_chapter_duration accepts durations within 5% and rejects beyond"
    - "convert_chapters_to_timestamps produces HH:MM:SS.mmm format from Audnexus JSON"
  artifacts:
    - path: "lib/audnexus.sh"
      provides: "Audnexus API client with caching, cover art, chapter conversion"
      exports: ["fetch_audnexus_book", "fetch_audnexus_chapters", "download_cover_art", "validate_chapter_duration", "convert_chapters_to_timestamps", "extract_metadata_fields"]
    - path: "config.env.example"
      provides: "Audnexus config vars documentation"
      contains: "AUDNEXUS_CACHE_DIR"
  key_links:
    - from: "lib/audnexus.sh"
      to: "lib/core.sh"
      via: "sources logging functions"
      pattern: "log_(info|warn|error|debug)"
    - from: "lib/audnexus.sh"
      to: "lib/ffmpeg.sh"
      via: "get_duration for chapter validation"
      pattern: "get_duration"
    - from: "lib/audnexus.sh"
      to: "https://api.audnex.us"
      via: "curl HTTP requests"
      pattern: "curl.*api\\.audnex\\.us"
---

<objective>
Create lib/audnexus.sh -- a shell library providing Audnexus API integration for book metadata lookup, chapter data retrieval, cover art download, and file-based caching with graceful degradation on all failure paths.

Purpose: Encapsulate all Audnexus HTTP interactions and response parsing into reusable functions that plan 02-03 (tone tagging stage) will consume. Isolating API logic here keeps the stage script focused on orchestration.

Output: lib/audnexus.sh (sourced by stages, never executed directly)
</objective>

<execution_context>
@/Users/rico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-metadata-enrichment/02-RESEARCH.md
@lib/core.sh
@lib/ffmpeg.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/audnexus.sh with API client, caching, and metadata extraction</name>
  <files>lib/audnexus.sh, config.env.example</files>
  <action>
Create lib/audnexus.sh following the patterns in lib/ffmpeg.sh (header comment, sourced-only, requires lib/core.sh). The file must contain these functions:

**fetch_audnexus_book()**
- Args: `$1` = ASIN (10-char alphanumeric), `$2` = cache_dir (defaults to `${AUDNEXUS_CACHE_DIR:-$WORK_DIR}`)
- Cache file: `$cache_dir/audnexus_book_${asin}.json`
- Check cache first: if file exists and younger than `${AUDNEXUS_CACHE_DAYS:-30}` days, cat and return 0
- Use portable stat: `stat -f %m` on macOS, `stat -c %Y` on Linux -- detect with `uname`
- Fetch: `curl -fsSL --max-time 30 "https://api.audnex.us/books/${asin}?region=${AUDNEXUS_REGION:-us}"`
- Validate response is valid JSON with `jq empty`
- Only cache 200 responses (curl -f ensures non-200 returns non-zero)
- On failure: log_warn (not log_error -- degradation, not crash), return 1
- Never cache error responses

**fetch_audnexus_chapters()**
- Same pattern as fetch_audnexus_book but hits `/books/${asin}/chapters`
- Cache file: `$cache_dir/audnexus_chapters_${asin}.json`
- 404 is expected (not all books have chapters) -- log_info, return 1
- Check `isAccurate` field: if false, log_warn "Audnexus reports chapters may be inaccurate for $asin" but still return the data

**download_cover_art()**
- Args: `$1` = book_json (string, full JSON), `$2` = output_path
- Extract `.image` from JSON with jq. If empty/null, log_warn and return 1
- Upgrade resolution: `sed 's/_SL[0-9]*_/_SL2000_/'`
- Download high-res with curl. If that fails, retry with original URL
- Validate JPEG magic bytes: `xxd -l 3 -p "$output_path" | grep -q '^ffd8ff'`
- On invalid JPEG: rm the file, log_warn, return 1
- Log file size on success

**validate_chapter_duration()**
- Args: `$1` = m4b_file, `$2` = audnexus_runtime_ms
- Get M4B duration via `get_duration` from lib/ffmpeg.sh (returns float seconds)
- Convert audnexus ms to seconds: `awk "BEGIN {printf \"%.3f\", $audnexus_runtime_ms / 1000}"`
- Calculate percentage difference using awk (NOT bc -- awk is more portable and already available)
- Threshold: `${CHAPTER_DURATION_TOLERANCE:-5}` percent (configurable)
- Return 0 if within tolerance, return 1 if exceeded
- Log the percentage difference at debug level on pass, warn level on fail

**convert_chapters_to_timestamps()**
- Args: `$1` = chapters_json (string, full JSON from chapters endpoint)
- Output: writes to stdout in tone simple timestamp format: `HH:MM:SS.mmm Title`
- Use jq to iterate `.chapters[]`, convert `startOffsetMs` to `HH:MM:SS.mmm`
- Sanitize chapter titles: strip control characters, trim whitespace
- jq expression handles the math: hours, minutes, seconds, milliseconds from startOffsetMs

**extract_metadata_fields()**
- Args: `$1` = book_json (string, full JSON)
- Output: prints shell-evaluable variable assignments to stdout (to be consumed with `eval`)
- Fields: META_TITLE, META_AUTHOR (comma-joined), META_NARRATOR (comma-joined), META_GENRE (first genre), META_DESCRIPTION (HTML stripped), META_RELEASE_DATE (ISO 8601 YYYY-MM-DD -- if only year available, append -01-01), META_SERIES_NAME, META_SERIES_POSITION (leading numeric portion only), META_ASIN
- Use jq for all extraction. Single jq call that outputs `KEY=value` lines
- Shell-escape values properly (single quotes with internal quote escaping)

**Config vars to add to config.env.example** (append to end):
```
# Audnexus API
AUDNEXUS_REGION="us"
AUDNEXUS_CACHE_DIR=""  # defaults to WORK_DIR if empty
AUDNEXUS_CACHE_DAYS=30
CHAPTER_DURATION_TOLERANCE=5  # percent
```

Keep lib/audnexus.sh under 400 lines. Use the same comment style as lib/ffmpeg.sh. Header: `# lib/audnexus.sh -- Audnexus API client (metadata, chapters, cover art, caching)`. Add `# Requires: lib/core.sh, lib/ffmpeg.sh sourced first; curl, jq available`.
  </action>
  <verify>
1. `bash -n lib/audnexus.sh` -- syntax check passes
2. `shellcheck lib/audnexus.sh` -- no errors (warnings acceptable for sourced files)
3. `grep -c '^[a-z_]*()' lib/audnexus.sh` -- returns 6 (all functions present)
4. `grep 'AUDNEXUS_CACHE_DIR' config.env.example` -- config vars present
5. `wc -l lib/audnexus.sh` -- under 400 lines
  </verify>
  <done>
lib/audnexus.sh exists with all 6 functions, passes bash -n syntax check, follows lib/ffmpeg.sh patterns, config.env.example updated with Audnexus vars. All API failure paths use log_warn (not log_error) for graceful degradation. Cache logic uses portable stat detection. No bc dependency -- awk for all math.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration smoke test against live Audnexus API</name>
  <files>lib/audnexus.sh</files>
  <action>
Source core.sh, ffmpeg.sh, and audnexus.sh in a test harness and run against a known ASIN to verify the library works end-to-end. Use ASIN `B002V5D1CG` (confirmed working in research -- validated 2026-02-20).

Run these checks in a temporary directory:

1. `fetch_audnexus_book B002V5D1CG /tmp/audnexus-test` -- should return JSON, create cache file
2. Verify cached response: run again, confirm log says "Using cached" (no HTTP request)
3. `fetch_audnexus_chapters B002V5D1CG /tmp/audnexus-test` -- should return chapters JSON
4. `extract_metadata_fields "$book_json"` -- should print META_TITLE, META_AUTHOR, etc.
5. `convert_chapters_to_timestamps "$chapters_json"` -- should output HH:MM:SS.mmm lines
6. `download_cover_art "$book_json" /tmp/audnexus-test/cover.jpg` -- should download JPEG
7. Verify cover.jpg exists and starts with JPEG magic bytes
8. Test graceful degradation: `fetch_audnexus_book INVALIDASIN /tmp/audnexus-test` -- should return 1 without crashing

If any function fails, fix the issue in lib/audnexus.sh and re-test. Do NOT leave known failures. Clean up /tmp/audnexus-test when done.

**Important:** This is a functional smoke test, not a unit test suite. The goal is to catch integration bugs (wrong jq paths, curl flags, stat portability) before the stage script uses these functions.
  </action>
  <verify>
1. All 8 checks pass without error
2. Cache file exists at expected path after first fetch
3. Cover art is valid JPEG (magic bytes confirmed)
4. extract_metadata_fields output is eval-safe (no unescaped quotes breaking shell)
5. convert_chapters_to_timestamps output matches `HH:MM:SS.mmm Title` format
6. Invalid ASIN returns non-zero without set -e crash
  </verify>
  <done>
All Audnexus API functions verified working against live API with known ASIN. Cache hit path confirmed. Cover art download confirmed. Graceful degradation on invalid ASIN confirmed. Any bugs found during testing have been fixed in lib/audnexus.sh.
  </done>
</task>

</tasks>

<verification>
1. `bash -n lib/audnexus.sh` passes (valid syntax)
2. All 6 exported functions exist and are callable
3. File-based caching creates and reads JSON cache files correctly
4. Cover art download produces valid JPEG
5. Chapter timestamp conversion outputs correct format
6. API failure paths degrade gracefully (return 1, log warning, never crash)
7. config.env.example contains AUDNEXUS_* variables
8. lib/audnexus.sh stays under 400 lines
</verification>

<success_criteria>
lib/audnexus.sh is a complete, tested API client library that plan 02-03 can source and call without needing to know anything about HTTP, caching, or JSON parsing. All Audnexus interactions are encapsulated. All failure modes degrade gracefully. Config is documented in config.env.example.
</success_criteria>

<output>
After completion, create `.planning/phases/02-metadata-enrichment/02-02-SUMMARY.md`
</output>
