---
phase: 02-metadata-enrichment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/asin.sh
  - stages/05-asin.sh
  - config.env.example
  - lib/manifest.sh
  - bin/audiobook-convert
autonomous: true

must_haves:
  truths:
    - "A .asin file containing a valid ASIN is read and its value stored in the manifest"
    - "An ASIN embedded in a folder name (brackets, parens, prefix) is extracted and stored in the manifest"
    - "Discovered ASINs are validated against Audnexus API before being trusted"
    - "Pipeline continues without error when no ASIN is found (graceful degradation)"
    - "ASIN discovery respects priority order: .asin file > folder regex > Readarr API config hook"
  artifacts:
    - path: "lib/asin.sh"
      provides: "ASIN discovery functions (manual file, regex, Readarr stub, Audnexus validation)"
      contains: "discover_asin"
    - path: "stages/05-asin.sh"
      provides: "Stage 05 ASIN discovery integration with manifest"
      contains: "stage_asin"
    - path: "config.env.example"
      provides: "Readarr API config hooks (READARR_API_URL, READARR_API_KEY)"
      contains: "READARR_API_URL"
  key_links:
    - from: "stages/05-asin.sh"
      to: "lib/asin.sh"
      via: "source and call discover_asin"
      pattern: "source.*lib/asin.sh"
    - from: "stages/05-asin.sh"
      to: "lib/manifest.sh"
      via: "manifest_update with .metadata.asin"
      pattern: "manifest_update.*asin"
    - from: "bin/audiobook-convert"
      to: "stages/05-asin.sh"
      via: "STAGE_MAP and STAGE_ORDER arrays"
      pattern: "\\[asin\\]"
---

<objective>
Implement ASIN discovery for audiobooks using a priority chain: manual `.asin` file (P0), folder name regex extraction (P1), and a Readarr API config hook (deferred implementation, config-only).

Purpose: ASIN is the key that unlocks all downstream metadata enrichment (02-02 Audnexus lookup, 02-03 tone tagging). Without a reliable ASIN, the pipeline falls back to file-boundary chapters and no metadata.

Output: `lib/asin.sh` library with discovery functions, `stages/05-asin.sh` stage wired into the pipeline, ASIN stored in manifest for downstream stages.
</objective>

<execution_context>
@/Users/rico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-metadata-enrichment/02-RESEARCH.md

# Existing codebase patterns (follow these conventions exactly)
@lib/core.sh
@lib/manifest.sh
@stages/01-validate.sh
@bin/audiobook-convert
@config.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/asin.sh with discovery priority chain and Audnexus validation</name>
  <files>lib/asin.sh, config.env.example</files>
  <action>
Create `lib/asin.sh` following the same conventions as `lib/core.sh` and `lib/manifest.sh`:
- Shebang: `#!/usr/bin/env bash`
- Header comment: `# lib/asin.sh -- ASIN discovery via priority chain (.asin file, folder regex, Readarr API)`
- `set -euo pipefail`
- Requires: `lib/core.sh` sourced first (for `log_info`, `log_warn`, `log_debug`, `die`)

Implement these functions:

**`check_manual_asin_file "$source_dir"`**
- Look for `$source_dir/.asin` file
- Read contents, trim whitespace, uppercase via `tr '[:lower:]' '[:upper:]'`
- Validate format with regex `^B0[A-Z0-9]{8}$`
- Return ASIN on stdout if valid, return 1 if file missing or invalid
- Log at INFO level when found, WARN when file exists but format invalid

**`extract_asin_from_folder "$source_dir"`**
- Get folder name via `basename "$source_dir"`
- Uppercase the folder name before matching
- Try regex patterns in order (use `BASH_REMATCH`):
  1. `\[([A-Z0-9]{10})\]` -- brackets: `Book Title [B00JCDK5ME]`
  2. `\(([A-Z0-9]{10})\)` -- parens: `Book Title (B00JCDK5ME)`
  3. `^([A-Z0-9]{10})[[:space:]]*-` -- prefix: `B00JCDK5ME - Book Title`
- For each match, verify it starts with `B0` (audiobook ASIN prefix)
- Return first valid match on stdout, return 1 if none found
- Log extracted ASIN and which pattern matched at INFO level

**`validate_asin_format "$asin"`**
- Pure format check: `[[ "$asin" =~ ^B0[A-Z0-9]{8}$ ]]`
- No API call. Returns 0 if valid format, 1 if not.

**`validate_asin_against_audnexus "$asin"`**
- `curl -s -w "\n%{http_code}" --max-time 10 "https://api.audnex.us/books/$asin"`
- Parse HTTP status code from last line of response
- 200: return 0 (valid), log_debug
- 404: return 1, log_warn "ASIN not found in Audnexus"
- 422: return 1, log_warn "Invalid ASIN format rejected by Audnexus"
- Network error (curl fails): return 1, log_warn "Audnexus API unreachable -- skipping validation"
- Any other HTTP code: return 1, log_error with status code
- IMPORTANT: Do not cache error responses. Only the discovery function stores results.

**`query_readarr_for_asin "$source_dir"`**
- Stub implementation: check if `READARR_API_URL` and `READARR_API_KEY` are set
- If not set, `log_debug "Readarr API not configured -- skipping"` and return 1
- If set, log_info that Readarr lookup is not yet implemented and return 1
- This is a config hook for future 02-01 gap closure or Phase 4 work

**`discover_asin "$source_dir"`**
- Priority chain orchestrator. Calls methods in order, validates each result against Audnexus.
- Priority 1: `check_manual_asin_file` -- if returns ASIN and `validate_asin_against_audnexus` passes, echo ASIN and return 0
- Priority 2: `extract_asin_from_folder` -- same validation pattern
- Priority 3: `query_readarr_for_asin` -- same validation pattern
- If Audnexus validation fails but format is valid, log_warn and try next method (don't trust unvalidated ASINs)
- If Audnexus is unreachable (network error on ALL attempts), accept format-valid ASINs with a warning: "Audnexus unreachable -- using unvalidated ASIN"
- If all methods fail, log_warn "No valid ASIN found" and return 1
- Log the discovery source (e.g., "ASIN discovered via .asin file: B00JCDK5ME")

Also update `config.env.example` to add these lines at the end, under a new `# Metadata enrichment` comment section:
```
# Metadata enrichment
# READARR_API_URL=""     # e.g., http://localhost:8787/api/v1
# READARR_API_KEY=""     # Readarr API key from Settings > General
```
  </action>
  <verify>
Syntax check: `bash -n lib/asin.sh` exits 0.
Config has Readarr vars: `grep -q READARR_API_URL config.env.example`.
All functions defined: `grep -c '^[a-z_]*()' lib/asin.sh` returns 6.
  </verify>
  <done>
lib/asin.sh has all 6 functions (check_manual_asin_file, extract_asin_from_folder, validate_asin_format, validate_asin_against_audnexus, query_readarr_for_asin, discover_asin). config.env.example has commented-out READARR_API_URL and READARR_API_KEY. File passes bash -n syntax check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stages/05-asin.sh and wire into pipeline orchestrator</name>
  <files>stages/05-asin.sh, lib/manifest.sh, bin/audiobook-convert</files>
  <action>
**Create `stages/05-asin.sh`** following the exact pattern of `stages/01-validate.sh`:

```bash
#!/usr/bin/env bash
# stages/05-asin.sh -- Discover ASIN for the audiobook via priority chain
# Stores discovered ASIN in manifest for downstream metadata stages.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
STAGE="asin"

source "$SCRIPT_DIR/lib/core.sh"
source "$SCRIPT_DIR/lib/manifest.sh"
source "$SCRIPT_DIR/lib/asin.sh"
```

Implement `stage_asin()`:
- Check required env vars: `WORK_DIR`, `SOURCE_PATH`, `BOOK_HASH`
- Call `discover_asin "$SOURCE_PATH"`
- If ASIN found (exit 0):
  - Store in manifest: `manifest_update "$BOOK_HASH" ".metadata.asin = \"$asin\" | .metadata.asin_source = \"$source\""`
  - Where `$source` is "manual", "folder_regex", or "readarr" depending on which method succeeded
  - To determine source, call each method individually instead of relying on discover_asin, OR restructure discover_asin to also output the source. Simpler approach: have discover_asin output "SOURCE:ASIN" format (e.g., "manual:B00JCDK5ME") and parse in the stage.
  - Actually, cleaner approach: modify discover_asin to set a global `ASIN_SOURCE` variable before echoing. The stage reads it after the call.
  - Write ASIN to `$WORK_DIR/asin.txt` for downstream stages that don't read manifests
  - `manifest_set_stage "$BOOK_HASH" "asin" "completed"`
  - log_info with ASIN value and source
- If ASIN not found (exit 1):
  - `manifest_set_stage "$BOOK_HASH" "asin" "completed"` -- NOT failed. Missing ASIN is graceful degradation, not failure.
  - `manifest_update "$BOOK_HASH" '.metadata.asin = null | .metadata.asin_source = "none"'`
  - log_info "No ASIN found -- metadata enrichment will be skipped in downstream stages"
- Add the `if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then stage_asin; fi` guard at the bottom

**Update `lib/manifest.sh`** -- Add "asin" to the `manifest_create` function's stages object:
- Find the `stages:` block in the `jq -n` call inside `manifest_create()`
- Add `asin: { status: "pending" }` after the cleanup stage
- This ensures the manifest schema includes the new stage from creation

**Update `bin/audiobook-convert`** -- Wire stage 05 into the pipeline:
- Add `source "$LIB_DIR/asin.sh"` after the sanitize.sh source line
- Add `[asin]="05"` to the `STAGE_MAP` associative array
- Add `asin` to the end of the `STAGE_ORDER` array (after cleanup)
- Wait -- asin should run BEFORE cleanup, not after. Looking at the pipeline flow: validate -> concat -> convert -> cleanup. ASIN discovery should run after validate (needs SOURCE_PATH) but doesn't depend on concat/convert. However, it's logically Phase 2 content and the cleanup stage is the Phase 1 finisher. Insert asin AFTER cleanup in the stage order so Phase 1 stages remain intact and Phase 2 stages come after. The existing cleanup stage marks Phase 1 output as done. ASIN discovery starts the metadata enrichment chain.
- Final STAGE_ORDER: `(validate concat convert cleanup asin)` -- asin runs after cleanup, which is correct because it only needs SOURCE_PATH (set at pipeline start) and WORK_DIR (exists throughout).
  </action>
  <verify>
Syntax checks pass: `bash -n stages/05-asin.sh && bash -n lib/manifest.sh && bash -n bin/audiobook-convert`.
Stage wired: `grep -q 'asin' bin/audiobook-convert`.
Manifest has asin stage: `grep -q 'asin' lib/manifest.sh`.
Stage follows pattern: `grep -q 'stage_asin' stages/05-asin.sh`.
  </verify>
  <done>
stages/05-asin.sh exists with stage_asin() that calls discover_asin, stores result in manifest (.metadata.asin + .metadata.asin_source), writes asin.txt to work dir, and handles graceful degradation. Pipeline orchestrator (bin/audiobook-convert) includes asin in STAGE_MAP and STAGE_ORDER. Manifest schema includes asin stage. All files pass bash -n.
  </done>
</task>

</tasks>

<verification>
1. `bash -n lib/asin.sh && bash -n stages/05-asin.sh && bash -n lib/manifest.sh && bash -n bin/audiobook-convert` -- all syntax checks pass
2. `grep -c 'function\|^[a-z_]*()' lib/asin.sh` -- 6 functions defined
3. `grep 'STAGE_ORDER' bin/audiobook-convert` -- shows asin in the array
4. `grep 'asin.*pending' lib/manifest.sh` -- asin stage in manifest schema
5. `grep 'READARR_API' config.env.example` -- config hook present
</verification>

<success_criteria>
- lib/asin.sh implements the full ASIN discovery priority chain with Audnexus validation
- stages/05-asin.sh integrates ASIN discovery into the pipeline as a manifest-tracked stage
- Pipeline gracefully degrades when no ASIN is found (stage completes, not fails)
- Readarr API has a config hook (env vars in config.env.example) but implementation is deferred
- All modified files pass bash -n syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/02-metadata-enrichment/02-01-SUMMARY.md`
</output>
