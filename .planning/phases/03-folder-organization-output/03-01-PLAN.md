---
phase: 03-folder-organization-output
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/organize.sh
  - stages/07-organize.sh
  - bin/audiobook-convert
  - lib/manifest.sh
  - config.env.example
autonomous: true

must_haves:
  truths:
    - "Books with series metadata land in /mnt/media/AudioBooks/Author/Series Name/NN Title (Year)/Title.m4b"
    - "Books without series land in /mnt/media/AudioBooks/Author/Title (Year)/Title.m4b"
    - "Filenames and directories are sanitized with UTF-8 byte-aware truncation to 255 bytes"
    - "Companion files (cover.jpg, desc.txt, reader.txt) deploy alongside M4B"
    - "Missing metadata falls back gracefully (Unknown Author, omit series folder, omit year)"
  artifacts:
    - path: "lib/organize.sh"
      provides: "Plex path construction, NFS-safe copy, sanitization"
      exports: ["sanitize_folder_component", "build_plex_path", "copy_to_nfs_safe", "check_nfs_available", "deploy_companion_files"]
    - path: "stages/07-organize.sh"
      provides: "Organize stage implementation"
      exports: ["stage_organize"]
    - path: "bin/audiobook-convert"
      provides: "Pipeline orchestration with organize stage"
      contains: "[organize]=\"07\""
    - path: "lib/manifest.sh"
      provides: "Manifest schema with organize stage"
      contains: "organize:"
  key_links:
    - from: "stages/07-organize.sh"
      to: "lib/organize.sh"
      via: "source and function calls"
      pattern: "source.*lib/organize.sh"
    - from: "stages/07-organize.sh"
      to: "manifest metadata fields"
      via: "manifest_read for author/title/series/year"
      pattern: "manifest_read.*metadata\\."
    - from: "lib/organize.sh"
      to: "NFS mount point"
      via: "cp+chmod not install"
      pattern: "cp.*chmod.*not.*install"
---

<objective>
Organize tagged M4B files into Plex-compatible folder structure on NFS mount with sanitized filenames.

Purpose: Replace the current 04-cleanup.sh simple output with Plex-aware folder hierarchy. This enables proper library organization with series support, metadata-driven paths, and companion file deployment. Phase 3 Plan 1 creates the organize stage infrastructure; Plan 2 will add archive validation.

Output:
- lib/organize.sh library with folder structure logic
- stages/07-organize.sh stage implementation
- Updated pipeline orchestration with organize+archive split
</objective>

<execution_context>
@/Users/rico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-folder-organization-output/03-RESEARCH.md

Existing codebase:
@bin/audiobook-convert
@lib/manifest.sh
@lib/sanitize.sh
@lib/metadata.sh
@stages/04-cleanup.sh
@config.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/organize.sh with Plex path construction and NFS-safe operations</name>
  <files>lib/organize.sh</files>
  <action>
Create lib/organize.sh with the following functions:

**sanitize_folder_component()** -- Space-based replacement, UTF-8 byte-aware truncation
- Input: $1 = component (author name, series name, book title)
- Replace invalid chars with spaces (not underscores): `s/[\/\\:"*?<>|;]+/ /g`
- Normalize whitespace: collapse multiple spaces, trim leading/trailing
- Truncate to 255 bytes using `printf '%s' "$var" | wc -c` (byte count, not character count)
- Handle UTF-8 multi-byte truncation safely (don't split mid-character)
- Output: sanitized string

**build_plex_path()** -- Construct Author/Series/Title path from metadata with fallbacks
- Input: $1 = base_dir, $2 = book_hash (for manifest_read)
- Read metadata fields: author, title, series_name, series_position, year
- Fallbacks (per research):
  - Author: manifest metadata.author -> metadata.artist -> basename of source_path -> "Unknown Author"
  - Title: manifest metadata.title -> basename of source_path -> "Unknown Title - HASH"
  - Series: if empty, omit series folder entirely (no "Unknown Series")
  - Year: if empty, omit from folder name (no parentheses)
- Sanitize each component with sanitize_folder_component()
- Build path:
  - With series: `$base_dir/$author/$series/$position - $title ($year)/`
  - No series: `$base_dir/$author/$title ($year)/`
  - No year: omit `($year)` entirely
- Zero-pad series_position to 2 digits (01-99), handle decimals (01.5)
- Output: full directory path (not including filename)

**copy_to_nfs_safe()** -- cp+chmod wrapper (NOT install due to root squash)
- Input: $1 = source_file, $2 = dest_path, $3 = file_mode (default 644), $4 = dir_mode (default 755)
- Create parent directory with mkdir -p
- Use cp (not install) to avoid NFS root squash chown failures
- Apply chmod after copy
- Log operation with file size
- Return non-zero on failure

**check_nfs_available()** -- Timeout-based NFS mount check
- Input: $1 = nfs_path
- Use `timeout 5 ls "$nfs_path"` to detect stale NFS mounts
- Return 0 if accessible, 1 if timeout/error
- Log warning on failure

**deploy_companion_files()** -- Copy cover.jpg, desc.txt, reader.txt to output folder
- Input: $1 = work_dir, $2 = output_dir
- For each file in (cover.jpg desc.txt reader.txt):
  - If exists in work_dir, copy to output_dir with copy_to_nfs_safe
  - Log each deployment
- Non-fatal if files missing (metadata stage may have skipped them)

Use same header pattern as lib/metadata.sh:
```bash
#!/usr/bin/env bash
# lib/organize.sh -- Plex folder structure generation and NFS-safe file operations
# Sourced by stages/07-organize.sh; do not execute directly.
# Requires: lib/core.sh (logging), lib/manifest.sh (metadata reads)
```

Source dependencies: lib/core.sh, lib/manifest.sh (for manifest_read in build_plex_path)
  </action>
  <verify>
- `bash -n lib/organize.sh` syntax check passes
- All 5 functions defined: grep -E "^(sanitize_folder_component|build_plex_path|copy_to_nfs_safe|check_nfs_available|deploy_companion_files)\(\)" lib/organize.sh
- UTF-8 byte counting uses `wc -c` not `${#var}`: grep "wc -c" lib/organize.sh
- No install usage for NFS: ! grep "install.*-o" lib/organize.sh
  </verify>
  <done>
lib/organize.sh exists with all 5 functions, using cp+chmod (not install), UTF-8 byte-aware sanitization, metadata fallback logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stages/07-organize.sh and update pipeline orchestration</name>
  <files>stages/07-organize.sh, bin/audiobook-convert, lib/manifest.sh</files>
  <action>
**Create stages/07-organize.sh:**
- Follow stage pattern from 06-metadata.sh (set -euo pipefail, source libs, stage function)
- source: lib/core.sh, lib/manifest.sh, lib/organize.sh, lib/metadata.sh (for generate_companions)
- Required env vars: WORK_DIR, BOOK_HASH, NFS_OUTPUT_DIR (or fall back to OUTPUT_DIR)
- Idempotency: Check manifest stages.organize.status at start, skip if "completed"
- Read metadata from manifest: author, title, series_name, series_position, year
- Call build_plex_path() to construct output directory
- Call check_nfs_available() before operations (5s timeout)
- Create directory structure with mkdir -p
- Locate M4B from manifest stages.metadata.output_file (or stages.convert.output_file if metadata stage skipped)
- Copy M4B to final location with copy_to_nfs_safe()
- If CREATE_COMPANION_FILES=true, call deploy_companion_files()
- Update manifest: stages.organize.output_path, stages.organize.completed (mark stage completed)
- Log final path

**Update bin/audiobook-convert:**
- Add to STAGE_MAP: `[organize]="07"` and renumber cleanup: `[cleanup]="09"`
- Update STAGE_ORDER: `(validate concat convert asin metadata organize cleanup)` (archive will be added in 03-02)
- Add source line after lib/metadata.sh: `source "$LIB_DIR/organize.sh"`

**Update lib/manifest.sh:**
- In manifest_create(), add organize stage to stages object: `organize: { status: "pending" }`
- In get_next_stage() loop, add organize to stage list: `for stage in validate concat convert asin metadata organize cleanup`

Note: Archive stage (08) will be added in Plan 03-02, so cleanup stays at 09 for now but organize is 07
  </action>
  <verify>
- `bash -n stages/07-organize.sh` syntax check passes
- bin/audiobook-convert sources lib/organize.sh: grep "source.*lib/organize.sh" bin/audiobook-convert
- STAGE_MAP contains organize=07: grep '\[organize\]="07"' bin/audiobook-convert
- STAGE_ORDER includes organize: grep "organize" bin/audiobook-convert | grep STAGE_ORDER
- manifest_create includes organize stage: grep "organize:" lib/manifest.sh
- get_next_stage includes organize: grep "organize" lib/manifest.sh | grep "for stage"
  </verify>
  <done>
stages/07-organize.sh exists and implements idempotent Plex folder organization. Pipeline orchestration updated with organize stage in correct sequence.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add configuration variables for organize stage</name>
  <files>config.env.example</files>
  <action>
Add to config.env.example after the "Metadata enrichment (Phase 2)" section:

```bash
# Folder organization and output (Phase 3)
NFS_OUTPUT_DIR="/mnt/media/AudioBooks"  # Plex library root on NFS
CREATE_COMPANION_FILES=true             # Deploy cover.jpg, desc.txt, reader.txt alongside M4B
```

Add comment above existing OUTPUT_DIR explaining it's for work-in-progress, NFS_OUTPUT_DIR is for final Plex location:
```bash
# Directories
WORK_DIR="/var/lib/audiobook-pipeline/work"
MANIFEST_DIR="/var/lib/audiobook-pipeline/manifests"
OUTPUT_DIR="/var/lib/audiobook-pipeline/output"  # Fallback if NFS_OUTPUT_DIR not set
LOG_DIR="/var/log/audiobook-pipeline"
```

Do NOT add ARCHIVE_DIR yet (that's Plan 03-02 scope).
  </action>
  <verify>
- grep "NFS_OUTPUT_DIR" config.env.example
- grep "CREATE_COMPANION_FILES" config.env.example
- Config file still has valid bash syntax: bash -n config.env.example
  </verify>
  <done>
config.env.example contains NFS_OUTPUT_DIR and CREATE_COMPANION_FILES variables with descriptive comments
  </done>
</task>

</tasks>

<verification>
Overall phase checks after all tasks complete:

1. **Library exists and exports functions:**
   ```bash
   source lib/organize.sh
   declare -F sanitize_folder_component build_plex_path copy_to_nfs_safe check_nfs_available deploy_companion_files
   ```

2. **Stage integrated into pipeline:**
   ```bash
   grep -q '\[organize\]="07"' bin/audiobook-convert
   grep -q "organize" lib/manifest.sh
   ```

3. **No install usage for NFS operations:**
   ```bash
   ! grep -r "install.*-o" lib/organize.sh stages/07-organize.sh
   ```

4. **UTF-8 byte counting (not character counting):**
   ```bash
   grep -q "wc -c" lib/organize.sh
   ```

5. **Fallback logic present:**
   ```bash
   grep -E "(Unknown Author|Unknown Title)" lib/organize.sh
   ```
</verification>

<success_criteria>
Plan 03-01 is complete when:

1. lib/organize.sh exists with all 5 required functions
2. stages/07-organize.sh exists and implements organize logic
3. bin/audiobook-convert has organize stage in STAGE_MAP and STAGE_ORDER
4. lib/manifest.sh includes organize stage in schema and get_next_stage
5. config.env.example has NFS_OUTPUT_DIR and CREATE_COMPANION_FILES variables
6. All bash files pass syntax checks (`bash -n`)
7. No install usage with -o flag (NFS incompatible)
8. Sanitization uses byte counting, not character counting
9. Metadata fallbacks implemented (Unknown Author, omit series, omit year)

Observable behavior:
- Pipeline orchestration knows about organize stage (wave structure updated in 03-02 with archive)
- Plex path construction logic ready for execution
- NFS-safe copy operations ready (cp+chmod, not install)
</success_criteria>

<output>
After completion, create `.planning/phases/03-folder-organization-output/03-01-SUMMARY.md` following the standard summary template.
</output>
