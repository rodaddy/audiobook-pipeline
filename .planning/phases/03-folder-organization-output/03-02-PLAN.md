---
phase: 03-folder-organization-output
plan: 02
title: Archive stage with verification gate
estimated_tasks: 3
depends_on: [03-01]
---

# Plan 03-02: Archive Stage with Verification Gate

## Overview

Implement stage 08 (archive) to safely move original MP3 files to an archive directory AFTER validating M4B integrity. This is the safety gate -- we only destroy originals when we're confident the output is valid.

**Critical constraint:** This plan depends on 03-01 being executed first. The organize stage (07) must exist and set `output_path` in the manifest before archive can reference it.

## Objectives

1. Comprehensive M4B validation library (6-point check)
2. Archive stage that validates before moving originals
3. Pipeline wiring: source lib, update STAGE_MAP, renumber cleanup
4. Config additions: ARCHIVE_DIR, ARCHIVE_RETENTION_DAYS

## Context

From research:
- M4B must pass 6 validation checks before archive: exists, ffprobe parses, duration > 0, codec AAC, container mov/mp4, file size within 10% expected
- Archive structure: flat ARCHIVE_DIR/book-basename/ (simple recovery)
- Cross-filesystem moves: use cp+verify+rm pattern (not atomic mv)
- Idempotent: check manifest status, check if already archived
- Cleanup stage renumbers: 04-cleanup.sh -> 09-cleanup.sh

## Tasks

### Task 1: Create lib/archive.sh with validation library

**Files:**
- `lib/archive.sh` (create)

**Implementation:**

Create archive library with two core functions:

1. **validate_m4b_integrity()** -- comprehensive M4B validation:
   - Check 1: File exists and non-empty (`[[ -s "$file" ]]`)
   - Check 2: ffprobe can parse container (`ffprobe -v error "$file"`)
   - Check 3: Duration > 0 (`get_duration()` from lib/ffmpeg.sh)
   - Check 4: Codec is AAC (`get_codec()` returns "aac")
   - Check 5: Container format is mov/mp4 family (ffprobe `-show_entries format=format_name`)
   - Check 6: File size within 10% of expected (bitrate x duration / 8)
   - Returns 0 on success, 1 on any failure
   - Logs which check failed for debugging

2. **archive_originals()** -- move source files to archive:
   - Args: SOURCE_PATH, ARCHIVE_BASE_DIR, BOOK_BASENAME
   - Create archive directory: `ARCHIVE_DIR/book-basename/`
   - Detect if same filesystem as source (use `stat -f` on macOS, `stat -c %m` on Linux)
   - If same filesystem: use `mv` (atomic)
   - If cross-filesystem: use cp -> verify size matches -> rm source
   - Returns archive path on success
   - Idempotent: skip if source files already gone

**Dependencies:**
- Requires `lib/ffmpeg.sh` (get_duration, get_codec)
- Requires `lib/core.sh` (log_info, log_error, die)

**Acceptance:**
- [ ] `validate_m4b_integrity()` rejects file with wrong codec
- [ ] `validate_m4b_integrity()` rejects file with 0 duration
- [ ] `validate_m4b_integrity()` accepts valid M4B from convert stage
- [ ] `archive_originals()` moves files to correct archive path
- [ ] `archive_originals()` handles cross-filesystem moves correctly

**Testing approach:**
- Create test M4B (valid)
- Create invalid files (wrong codec, empty, corrupt)
- Call `validate_m4b_integrity()` on each
- Call `archive_originals()` with test source directory
- Verify files moved and source cleaned

---

### Task 2: Create stages/08-archive.sh

**Files:**
- `stages/08-archive.sh` (create)

**Implementation:**

Archive stage orchestration:

1. **Check idempotency:** Skip if `stages.archive.status == "completed"` in manifest
2. **Get organized M4B path:** Read `stages.organize.output_path` from manifest (set by stage 07)
3. **Validate M4B integrity:** Call `validate_m4b_integrity()` -- die if fails (fatal, do NOT archive)
4. **Determine archive directory:** Use ARCHIVE_DIR from config, create if missing
5. **Archive originals:** Call `archive_originals()` with SOURCE_PATH, ARCHIVE_DIR, book basename
6. **Update manifest:**
   - Set `stages.archive.status = "completed"`
   - Set `stages.archive.archive_path = <archive_path>`
   - Set `stages.archive.archived_at = <timestamp>`
   - Set `stages.archive.original_count = <number of MP3 files archived>`

**Error handling:**
- If M4B validation fails: die with clear error (originals preserved in SOURCE_PATH)
- If archive directory creation fails: die (filesystem issue)
- If archive move fails: die (leave manifest incomplete for retry)

**Dry-run support:**
- Log what would be archived
- Skip actual file moves
- Update manifest as usual (dry-run is global flag)

**Acceptance:**
- [ ] Stage skips if already completed (idempotency)
- [ ] Stage dies if M4B validation fails (safety gate)
- [ ] Stage dies if `output_path` not in manifest (dependency check)
- [ ] Originals moved to ARCHIVE_DIR/book-basename/
- [ ] Manifest updated with archive_path and archived_at
- [ ] Dry-run mode logs actions without moving files

---

### Task 3: Wire archive stage into pipeline

**Files:**
- `bin/audiobook-convert` (modify)
- `lib/manifest.sh` (modify)
- `stages/04-cleanup.sh` (rename to `stages/09-cleanup.sh`)
- `config.env.example` (modify)

**Implementation:**

1. **Update bin/audiobook-convert:**
   - Source `lib/archive.sh` (line ~121, after lib/metadata.sh)
   - Update STAGE_MAP: `[archive]="08"`, `[cleanup]="09"` (was "04")
   - Update STAGE_ORDER: `(validate concat convert asin metadata organize archive cleanup)`
   - Note: organize is added by 03-01, this plan adds archive

2. **Update lib/manifest.sh:**
   - Add `archive: { status: "pending" }` to manifest_create() stages object (line ~43)
   - Add `archive` to get_next_stage() loop (line ~143, before cleanup)

3. **Rename cleanup stage:**
   - `git mv stages/04-cleanup.sh stages/09-cleanup.sh`
   - Update shebang comment in 09-cleanup.sh: "stages/09-cleanup.sh"
   - Update STAGE variable: `STAGE="cleanup"` (unchanged, name stays same)

4. **Update config.env.example:**
   - Add section comment: `# Archive`
   - Add `ARCHIVE_DIR="/var/lib/audiobook-pipeline/archive"`
   - Add `ARCHIVE_RETENTION_DAYS=90` (future cleanup job will use this)
   - Note: local disk preferred over NFS (faster, no root squash issues)

5. **Set config defaults in bin/audiobook-convert:**
   - Line ~90-99: Add `ARCHIVE_DIR="${ARCHIVE_DIR:-/var/lib/audiobook-pipeline/archive}"`
   - Add to export line: `export ARCHIVE_DIR`

**Acceptance:**
- [ ] `audiobook-convert` sources lib/archive.sh
- [ ] STAGE_MAP includes archive="08", cleanup="09"
- [ ] STAGE_ORDER includes organize and archive in correct positions
- [ ] manifest_create includes archive stage
- [ ] get_next_stage loop includes archive
- [ ] cleanup stage renamed to 09-cleanup.sh (git history preserved)
- [ ] config.env.example documents ARCHIVE_DIR and ARCHIVE_RETENTION_DAYS
- [ ] Pipeline runs: validate -> concat -> convert -> asin -> metadata -> organize -> archive -> cleanup

**Testing approach:**
- Run pipeline with --dry-run flag
- Verify stages execute in correct order
- Check manifest has archive stage with pending status
- Confirm cleanup is the final stage (number 09)

---

## Verification

**End-to-end test (after 03-01 is complete):**

1. Run full pipeline on test audiobook:
   ```bash
   ./bin/audiobook-convert /path/to/test-book/
   ```

2. Verify archive stage behavior:
   - M4B validated before archive
   - Original MP3s moved to `ARCHIVE_DIR/test-book/`
   - Manifest shows `stages.archive.status = "completed"`
   - Manifest shows `archive_path` and `archived_at`

3. Test validation gate:
   - Corrupt the organized M4B (truncate file)
   - Re-run with --force
   - Verify pipeline dies at archive stage
   - Verify originals NOT moved (still in SOURCE_PATH)

4. Test idempotency:
   - Run pipeline again on same book
   - Verify archive stage skipped (already completed)

## Success Criteria

- [ ] lib/archive.sh provides validate_m4b_integrity() and archive_originals()
- [ ] stages/08-archive.sh validates M4B before moving originals
- [ ] Validation failure dies gracefully (preserves originals)
- [ ] Validation success archives originals to ARCHIVE_DIR/book-basename/
- [ ] Manifest updated with archive metadata
- [ ] cleanup stage renumbered to 09
- [ ] STAGE_MAP and STAGE_ORDER updated
- [ ] config.env.example documents ARCHIVE_DIR
- [ ] Pipeline executes stages in correct order: ... -> organize -> archive -> cleanup

## Notes

**Dependency on 03-01:**
This plan assumes stage 07 (organize) exists and sets `stages.organize.output_path` in the manifest. If 03-01 is not executed first, archive will fail with "output_path not found" error.

**Cross-filesystem considerations:**
The `archive_originals()` function handles both same-filesystem moves (atomic `mv`) and cross-filesystem moves (cp+verify+rm). Archive directory defaults to local disk to avoid NFS complications.

**Future work (not in this plan):**
- Archive cleanup job (delete archives older than ARCHIVE_RETENTION_DAYS)
- Archive compression (tar.gz for space savings)
- Archive verification job (periodic integrity checks)
