---
phase: 01-core-conversion-pipeline
plan: 03
type: execute
wave: 3
depends_on: [01-01, 01-02]
files_modified:
  - bin/audiobook-convert
  - stages/04-cleanup.sh
autonomous: true

must_haves:
  truths:
    - "./bin/audiobook-convert /path/to/book/ produces a single M4B with chapters (orchestrates stages 01-04)"
    - "Re-running the same book logs 'already processed' and exits 0 without re-encoding"
    - "--force flag causes a completed book to be reprocessed from scratch"
    - "--dry-run flag previews all actions without writing any files or modifying manifests"
    - "Exit code 0 on success, non-zero on failure with meaningful error on stderr"
  artifacts:
    - path: "bin/audiobook-convert"
      provides: "Main CLI entry point -- argument parsing, idempotency checks, stage orchestration"
      contains: "DRY_RUN|FORCE|check_book_status|get_next_stage"
    - path: "stages/04-cleanup.sh"
      provides: "Final stage -- moves M4B to output dir, sets permissions, cleans work dir"
      contains: "stage_cleanup|CLEANUP_WORK_DIR"
  key_links:
    - from: "bin/audiobook-convert"
      to: "lib/manifest.sh"
      via: "source and call check_book_status / get_next_stage"
      pattern: "source.*lib/manifest\\.sh"
    - from: "bin/audiobook-convert"
      to: "stages/*.sh"
      via: "source and call stage functions sequentially"
      pattern: "source.*stages/"
    - from: "bin/audiobook-convert"
      to: "lib/core.sh"
      via: "source for logging, run(), die(), DRY_RUN"
      pattern: "source.*lib/core\\.sh"
    - from: "stages/04-cleanup.sh"
      to: "lib/manifest.sh"
      via: "update_manifest to mark cleanup completed"
      pattern: "update_manifest"
---

<objective>
Create the CLI entry point (`bin/audiobook-convert`) that parses arguments, checks idempotency via manifests, orchestrates stages 01-04 in sequence, and handles --dry-run / --force flags. Also create the final cleanup stage (`stages/04-cleanup.sh`).

Purpose: This is the user-facing interface -- the thing you actually run. Without it, the lib and stage scripts are just loose functions with no orchestrator.

Output: A working `bin/audiobook-convert` script and `stages/04-cleanup.sh`. After this plan, `./bin/audiobook-convert /path/to/book/` is the complete end-to-end pipeline.
</objective>

<execution_context>
@/Users/rico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-conversion-pipeline/01-RESEARCH.md
@.planning/phases/01-core-conversion-pipeline/01-01-SUMMARY.md
@.planning/phases/01-core-conversion-pipeline/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bin/audiobook-convert CLI entry point</name>
  <files>bin/audiobook-convert</files>
  <action>
Create `bin/audiobook-convert` as the main CLI entry point. Must be executable (`chmod +x`). Shebang: `#!/usr/bin/env bash`. Use `set -euo pipefail`.

**Argument parsing** (manual long-flag loop, no getopt):
- `--dry-run` -- sets `DRY_RUN=true` (exported, used by `run()` in lib/core.sh)
- `--force` -- sets `FORCE=true` (exported, skips idempotency check)
- `-v` / `--verbose` -- sets `VERBOSE=true`, lowers log level to DEBUG
- `-c` / `--config FILE` -- overrides config path (default: `$SCRIPT_DIR/../config.env`)
- `-h` / `--help` -- prints usage and exits 0
- Unknown `-*` flags -- `die "Unknown option: $1 (use --help)"`
- First non-flag positional arg is `SOURCE_PATH` (required, die if missing)
- Export `DRY_RUN`, `FORCE`, `VERBOSE` so stages see them

**show_help function:**
Print usage synopsis, flag descriptions, examples. Keep it short -- 15-20 lines max.

**Library sourcing:**
Resolve `SCRIPT_DIR` via `$(cd "$(dirname "$0")" && pwd)`. Set `LIB_DIR="$SCRIPT_DIR/../lib"` and `STAGE_DIR="$SCRIPT_DIR/../stages"`.
Source in order: `config.env`, `lib/core.sh`, `lib/ffmpeg.sh`, `lib/manifest.sh`, `lib/sanitize.sh`.

**main() function:**
1. Resolve `SOURCE_PATH` to absolute path (`readlink -f` or `realpath`)
2. Validate source directory exists and contains MP3s (die if not)
3. Generate `BOOK_HASH` via `generate_book_hash "$SOURCE_PATH"` (from lib/sanitize.sh)
4. Export `BOOK_HASH` so log lines include it
5. **Idempotency check:** Call `check_book_status "$BOOK_HASH"`. If status is "completed" AND `$FORCE` is not true, log_info "Already processed, skipping (use --force to reprocess)" and exit 0. If `$FORCE` is true and status is "completed", log_info "Force reprocessing" and reset the manifest (delete it or set status back to pending).
6. **Determine next stage:** Call `get_next_stage "$BOOK_HASH"` to support resuming partial runs. If a previous run failed at stage 02, re-running picks up from 02 without redoing 01.
7. **Initialize manifest:** If new book (no manifest), call `init_manifest "$BOOK_HASH" "$SOURCE_PATH"` to create the initial JSON manifest.
8. **Stage orchestration:** Run stages sequentially based on `get_next_stage` output. For each stage, source the stage file and call its function. Pattern:
   ```
   for stage in validate concat convert cleanup; do
     [[ $(get_next_stage "$BOOK_HASH") == "done" ]] && break
     local next=$(get_next_stage "$BOOK_HASH")
     [[ "$next" != "$stage" ]] && continue  # already completed
     source "$STAGE_DIR/${stage_num}-${stage}.sh"
     "stage_${stage}" "$SOURCE_PATH" "$BOOK_HASH"
   done
   ```
   Use a mapping: validate=01, concat=02, convert=03, cleanup=04.
9. **Final status:** After all stages, verify manifest status is "completed". Log success with total duration.
10. Exit 0 on success, non-zero on any stage failure (set -e handles this, but also trap ERR to log which stage failed).

**Error trap:**
Set `trap 'on_error $LINENO' ERR` that logs the failing line number and stage. If a stage fails, update manifest with `status=failed` and the error message. Do NOT clean up work directory on failure -- leave it for debugging.

**Key details from research:**
- `generate_book_hash` is in lib/sanitize.sh (source path + sorted file list -> sha256 -> first 16 chars)
- `check_book_status`, `get_next_stage`, `init_manifest`, `update_manifest` are in lib/manifest.sh
- `run()` in lib/core.sh already handles DRY_RUN gating
- Manifest location: `$MANIFEST_DIR/$BOOK_HASH.json` (MANIFEST_DIR from config.env)
- Work directory: `$WORK_DIR/$BOOK_HASH/` (WORK_DIR from config.env)
  </action>
  <verify>
- `bash -n bin/audiobook-convert` exits 0 (syntax check)
- `./bin/audiobook-convert --help` prints usage and exits 0
- `./bin/audiobook-convert` (no args) exits non-zero with error about missing SOURCE_PATH
- `./bin/audiobook-convert --bad-flag /tmp` exits non-zero with "Unknown option"
- `shellcheck bin/audiobook-convert` has no errors (warnings acceptable)
  </verify>
  <done>
bin/audiobook-convert exists, is executable, parses all flags correctly, sources libraries, and contains the full main() orchestration loop with idempotency checks, stage sequencing, and error trapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stages/04-cleanup.sh and verify end-to-end wiring</name>
  <files>stages/04-cleanup.sh</files>
  <action>
Create `stages/04-cleanup.sh` as the final pipeline stage. Shebang: `#!/usr/bin/env bash`.

**stage_cleanup() function** -- takes `$source_path` and `$book_hash` as arguments:

1. **Locate output M4B:** Read the output file path from the manifest (`stages.convert.output_file`). Resolve it relative to `$WORK_DIR/$book_hash/`.
2. **Verify output:** Validate the M4B exists and is non-zero size. Run `ffprobe -v error "$output_file"` to confirm it's a valid audio container. Die if validation fails -- do NOT proceed with cleanup if the output is bad.
3. **Move to output directory:** Copy the M4B from the work directory to `$OUTPUT_DIR` (from config.env). Use `install -m 644 -o "$FILE_OWNER" -g "$FILE_GROUP"` to set correct permissions during copy. The output path for Phase 1 is just `$OUTPUT_DIR/<sanitized_title>.m4b` -- Plex folder structure comes in Phase 3.
   - Extract title from manifest metadata or derive from source directory basename
   - Sanitize the filename via `sanitize_filename` (from lib/sanitize.sh)
   - Wrap the install command with `run()` so --dry-run skips it
4. **Update manifest:** Set `stages.cleanup.status=completed`, `stages.cleanup.completed_at` to current ISO timestamp, `stages.cleanup.output_path` to the final output location. Set top-level `status=completed`.
5. **Clean work directory:** If `$CLEANUP_WORK_DIR` is true (from config.env, default true), remove `$WORK_DIR/$book_hash/`. Wrap with `run()` for dry-run safety. Log what's being removed.
6. **Final log:** log_info with output path and total file size.

**DRY_RUN behavior:** When DRY_RUN=true, the function should log what it WOULD do (move file, set permissions, delete work dir) but not actually do any of it. The `run()` wrapper from lib/core.sh handles this for commands passed through it.

**Error handling:** If the M4B doesn't exist or ffprobe fails, die with a clear message. Do NOT update the manifest to completed. The calling script's ERR trap will mark the stage as failed.

**After creating the file**, verify end-to-end wiring by running syntax checks:
- `bash -n stages/04-cleanup.sh`
- `bash -n bin/audiobook-convert`
- Confirm bin/audiobook-convert correctly references stages/04-cleanup.sh in its stage loop
  </action>
  <verify>
- `bash -n stages/04-cleanup.sh` exits 0 (syntax check)
- `shellcheck stages/04-cleanup.sh` has no errors
- `grep -q 'stage_cleanup' stages/04-cleanup.sh` confirms the function exists
- `grep -q '04-cleanup' bin/audiobook-convert` confirms the CLI references this stage
- `grep -q 'CLEANUP_WORK_DIR' stages/04-cleanup.sh` confirms config variable is used
  </verify>
  <done>
stages/04-cleanup.sh exists with a stage_cleanup function that validates the output M4B, moves it to the output directory with correct permissions, updates the manifest to completed, and optionally removes the work directory. bin/audiobook-convert correctly orchestrates all four stages including cleanup.
  </done>
</task>

</tasks>

<verification>
1. `bash -n bin/audiobook-convert && bash -n stages/04-cleanup.sh` -- both parse without syntax errors
2. `shellcheck bin/audiobook-convert stages/04-cleanup.sh` -- no errors (SC2034 warnings for exported-but-unused-here vars are acceptable)
3. `./bin/audiobook-convert --help` prints usage and exits 0
4. `./bin/audiobook-convert` (no args) exits non-zero
5. `./bin/audiobook-convert --dry-run /path/to/test/book/` runs the full pipeline in preview mode without writing any files (requires 01-01 and 01-02 artifacts to exist)
6. `grep -c 'source.*stages/' bin/audiobook-convert` returns 4 (all four stages referenced)
7. `grep -q 'check_book_status' bin/audiobook-convert` confirms idempotency wiring
</verification>

<success_criteria>
- bin/audiobook-convert is executable and handles --dry-run, --force, --verbose, --config, --help
- Running on an already-processed book (manifest exists with status=completed) exits 0 with skip message
- Running with --force on a completed book reprocesses it
- stages/04-cleanup.sh validates output before moving, respects DRY_RUN, and marks manifest completed
- All four stages are orchestrated sequentially with resume support (get_next_stage)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-conversion-pipeline/01-03-SUMMARY.md`
</output>
